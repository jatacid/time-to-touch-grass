<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Time to Touch Grass</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Inter', sans-serif;
            user-select: none;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        h1 {
            position: absolute;
            top: 20px;
            right: 20px;
            margin: 0;
            font-weight: 300;
            letter-spacing: 2px;
            font-size: 1rem;
            opacity: 0.5;
            color: white;
        }

        .hud-top-left {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .score-container {
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            backdrop-filter: blur(5px);
        }

        .score-label {
            font-size: 0.8em;
            text-transform: uppercase;
            opacity: 0.8;
            margin-bottom: 5px;
        }

        #score-value {
            font-size: 2em;
            font-weight: bold;
            font-family: monospace;
        }

        .progress-container {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            backdrop-filter: blur(5px);
            width: 200px;
        }

        .progress-label {
            font-size: 0.8em;
            margin-bottom: 5px;
            opacity: 0.8;
        }

        .progress-bar-bg {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
        }

        #progress-bar-fill {
            height: 100%;
            background: #44aa00;
            transition: width 0.3s ease;
        }

        #achievements-list {
            display: flex;
            flex-direction: column;
            gap: 5px;
            max-height: 300px;
            overflow-y: auto;
            padding-right: 5px;
            pointer-events: none;
            /* Custom Scrollbar */
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.3) transparent;
        }

        /* Enable scrolling when paused (pointer unlocked) */
        body:not(.pointer-locked) #achievements-list {
            pointer-events: auto;
        }

        .achievement-item {
            background: rgba(255, 215, 0, 0.2);
            border: 1px solid rgba(255, 215, 0, 0.5);
            color: #ffd700;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 0.9em;
            display: flex;
            align-items: center;
            gap: 8px;
            animation: slideIn 0.5s ease-out;
        }

        @keyframes slideIn {
            from {
                transform: translateX(-20px);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Audio controls removed */
        button {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.4);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
        }

        button:hover {
            background: rgba(255, 255, 255, 0.4);
            transform: translateY(-2px);
        }

        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            font-size: 1.2em;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            pointer-events: none;
            transition: opacity 0.5s;
        }

        .hand-cursor {
            position: absolute;
            font-size: 100px;
            pointer-events: none;
            user-select: none;
            transform: translate(-50%, -50%);
            opacity: 0;
            transition: opacity 0.1s, transform 0.1s;
            filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.5));
        }

        #hand-left {
            left: 30%;
            bottom: 0;
            transform: translate(-50%, 100%) rotate(-20deg);
        }

        #hand-right {
            right: 30%;
            bottom: 0;
            transform: translate(50%, 100%) rotate(20deg) scaleX(-1);
        }

        #hand-left.active,
        #hand-right.active {
            opacity: 1;
            transform: translate(-50%, -50%) rotate(0deg);
            /* Center on cursor */
            z-index: 100;
        }

        #hand-right.active {
            transform: translate(-50%, -50%) rotate(0deg) scaleX(-1);
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.5);
            font-size: 20px;
            pointer-events: none;
        }

        #custom-cursor {
            display: none;
        }

        /* Virtual Joystick */
        #joystick-container {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 120px;
            height: 120px;
            pointer-events: auto;
            opacity: 0.7;
            display: none;
        }

        #joystick-base {
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.1));
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            position: relative;
            backdrop-filter: blur(5px);
        }

        #joystick-knob {
            width: 50px;
            height: 50px;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0.4));
            border: 2px solid rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s ease-out;
        }

        #touch-instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            font-size: 1.2em;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            pointer-events: none;
            transition: opacity 0.5s;
            display: none;
            opacity: 1;
        }

        /* Mobile Pause Button */
        #mobile-pause-btn {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            color: white;
            font-size: 24px;
            display: none;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            cursor: pointer;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        #mobile-pause-btn:active {
            background: rgba(255, 255, 255, 0.3);
            transform: translateX(-50%) scale(0.95);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 0.8rem;
                top: 10px;
                right: 10px;
            }

            .hud-top-left {
                top: 10px;
                left: 10px;
                gap: 8px;
            }

            .score-container {
                padding: 10px;
            }

            #score-value {
                font-size: 1.5em;
            }

            .progress-container {
                width: 150px;
                padding: 8px;
            }

            .progress-label {
                font-size: 0.7em;
            }

            .achievement-item {
                font-size: 0.8em;
                padding: 6px 10px;
            }

            #footer-links {
                font-size: 10px !important;
                bottom: 5px !important;
                left: 5px !important;
            }

            #footer-links a {
                margin-right: 5px !important;
                padding: 3px 6px !important;
            }

            #joystick-container {
                bottom: 20px;
                left: 20px;
                width: 100px;
                height: 100px;
            }

            #joystick-knob {
                width: 40px;
                height: 40px;
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 0.7rem;
            }

            .score-container {
                padding: 8px;
            }

            #score-value {
                font-size: 1.2em;
            }

            .progress-container {
                width: 120px;
            }

            #achievements-list {
                max-height: 200px;
            }

            #joystick-container {
                width: 90px;
                height: 90px;
                bottom: 15px;
                left: 15px;
            }

            #joystick-knob {
                width: 35px;
                height: 35px;
            }

            #mobile-pause-btn {
                width: 40px;
                height: 40px;
                font-size: 20px;
                top: 15px;
            }
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>
    <div id="custom-cursor">
        <div class="hand">‚úã</div>
    </div>

    <div id="ui-container">
        <h1>Time to Touch Grass</h1>
        <div class="hud-top-left">
            <div class="score-container">
                <div class="score-label">Grass Touched</div>
                <div id="score-value">0m</div>
            </div>
            <div class="progress-container">
                <div class="progress-label">Next: <span id="next-achievement-name">First Touch</span></div>
                <div class="progress-bar-bg">
                    <div id="progress-bar-fill" style="width: 0%"></div>
                </div>
            </div>
            <div id="achievements-list">
                <!-- Unlocked achievements will appear here -->
            </div>
        </div>

        <div id="instructions">
            <p>Click to Start</p>
            <p>WASD to Move</p>
            <p>Mouse to Look</p>
            <p>Hold Left/Right Click to Touch Grass</p>
            <p style="font-size: 0.8em; opacity: 0.7; margin-top: 10px;">Press ESC to Pause</p>
        </div>

        <div id="footer-links" style="position: absolute; bottom: 10px; left: 10px; text-align: left; pointer-events: auto; font-size: 12px; opacity: 0.8;">
            <a href="https://github.com/jatacid/time-to-touch-grass" target="_blank" style="color: white; text-decoration: none; margin-right: 10px; text-shadow: 1px 1px 2px black;">GitHub</a>
            <a href="https://www.paypal.com/donate/?hosted_button_id=9VFG2KJ8HW6EW" target="_blank" style="background-color: #ffcc00; color: black; padding: 4px 8px; border-radius: 3px; text-decoration: none; font-weight: bold; box-shadow: 1px 1px 2px rgba(0,0,0,0.5);">Donate</a>
        </div>

        <!-- Mobile Pause Button -->
        <button id="mobile-pause-btn">‚è∏</button>
    </div>

    <!-- Virtual Joystick for Mobile -->
    <div id="joystick-container">
        <div id="joystick-base">
            <div id="joystick-knob"></div>
        </div>
    </div>

    <div id="crosshair">+</div>
    <div id="hand-left" class="hand-cursor">‚úã</div>
    <div id="hand-right" class="hand-cursor">‚úã</div>

    <!-- Touch instructions (shown on mobile) -->
    <div id="touch-instructions">
        <p>Tap to Start</p>
        <p>Joystick to Move</p>
        <p>Touch Right Side to Interact with Grass</p>
        <p style="font-size: 0.8em; opacity: 0.7; margin-top: 10px;">Tap Screen to Resume</p>
    </div>

    <div id="achievement-popup" class="hidden">
        <div class="achievement-icon">üèÜ</div>
        <div class="achievement-text">
            <div class="achievement-title">Achievement Unlocked!</div>
            <div id="achievement-name">First Touch</div>
        </div>
    </div>
    <script type="module">
        import * as THREE from 'three';

        // --- Configuration ---
        const WORLD_RADIUS = 50;
        const GRASS_COUNT = 200000; // Increased density
        const GRASS_WIDTH = 0.1;
        const GRASS_HEIGHT = 1.5;
        const PLAYER_HEIGHT = 1.7;
        const MOVEMENT_SPEED = 10.0;
        const INTERACTION_RADIUS = 5.0;

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 40, 90);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // --- Player Setup ---
        const playerGroup = new THREE.Group();
        scene.add(playerGroup);
        // Start player on top of the world
        playerGroup.position.set(0, WORLD_RADIUS, 0);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
        camera.position.set(0, PLAYER_HEIGHT, 0);
        playerGroup.add(camera);

        // --- Lights ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(50, 100, 50);
        scene.add(directionalLight);

        // --- World (Sphere) ---
        const groundGeometry = new THREE.SphereGeometry(WORLD_RADIUS, 64, 64);
        const groundMaterial = new THREE.MeshStandardMaterial({
            color: 0x2b4a2b,
            roughness: 1.0
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        scene.add(ground);

        // --- Grass (Spherical Distribution) ---
        const grassVertexShader = `
          uniform float time;
          uniform float interactionRadius;
          uniform vec3 hand1Pos; 
          uniform float hand1Active;
          uniform vec3 hand2Pos; 
          uniform float hand2Active;
          
          // attribute vec3 instanceColor; // Handled by Three.js automatically
          
          varying vec2 vUv;
          varying float vHeight;
          varying vec3 vColor;
          
          // Simple noise
          float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
          float noise(vec2 st) {
              vec2 i = floor(st); vec2 f = fract(st);
              float a = random(i); float b = random(i + vec2(1.0, 0.0));
              float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0));
              vec2 u = f * f * (3.0 - 2.0 * f);
              return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
          }

          void main() {
            vUv = uv;
            vHeight = position.y;
            vColor = instanceColor; // Pass color to fragment
            
            // Instance Matrix contains the transformation to place grass on sphere surface
            vec4 worldPosition = instanceMatrix * vec4(position, 1.0);
            vec3 pos = worldPosition.xyz;
            
            vec3 normal = normalize(pos);
            
            // Wind
            float noiseVal = noise(pos.xz * 0.5 + time * 0.5); 
            vec3 tangent1 = cross(normal, vec3(0, 1, 0));
            if (length(tangent1) < 0.001) tangent1 = cross(normal, vec3(0, 0, 1));
            tangent1 = normalize(tangent1);
            vec3 tangent2 = cross(normal, tangent1);
            
            float windStrength = pow(vHeight / ${GRASS_HEIGHT.toFixed(1)}, 2.0) * 0.5;
            pos += tangent1 * sin(time * 2.0 + pos.x * 0.5) * windStrength * 0.5;
            pos += tangent2 * cos(time * 1.5 + pos.z * 0.5) * windStrength * 0.5;
            
            // Interaction
            if (hand1Active > 0.5) {
                float dist = distance(pos, hand1Pos);
                if (dist < interactionRadius) {
                    vec3 dir = normalize(pos - hand1Pos);
                    float push = (1.0 - dist / interactionRadius) * 2.0;
                    float pushFactor = pow(vHeight / ${GRASS_HEIGHT.toFixed(1)}, 2.0);
                    pos += dir * push * pushFactor;
                    pos -= normal * (push * pushFactor * 0.5); 
                }
            }
            
            if (hand2Active > 0.5) {
                float dist = distance(pos, hand2Pos);
                if (dist < interactionRadius) {
                    vec3 dir = normalize(pos - hand2Pos);
                    float push = (1.0 - dist / interactionRadius) * 2.0;
                    float pushFactor = pow(vHeight / ${GRASS_HEIGHT.toFixed(1)}, 2.0);
                    pos += dir * push * pushFactor;
                    pos -= normal * (push * pushFactor * 0.5);
                }
            }

            gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);
          }
        `;

        const grassMaterial = new THREE.ShaderMaterial({
            vertexShader: grassVertexShader,
            fragmentShader: `
                varying vec3 vColor;
                void main() { gl_FragColor = vec4(vColor, 1.0); }
            `,
            uniforms: {
                time: { value: 0 },
                interactionRadius: { value: INTERACTION_RADIUS },
                hand1Pos: { value: new THREE.Vector3() },
                hand1Active: { value: 0.0 },
                hand2Pos: { value: new THREE.Vector3() },
                hand2Active: { value: 0.0 },
            },
            side: THREE.DoubleSide
        });

        const grassGeometry = new THREE.PlaneGeometry(GRASS_WIDTH, GRASS_HEIGHT, 1, 4);
        grassGeometry.translate(0, GRASS_HEIGHT / 2, 0);

        const grassMesh = new THREE.InstancedMesh(grassGeometry, grassMaterial, GRASS_COUNT);

        const dummy = new THREE.Object3D();
        const _position = new THREE.Vector3();
        const _normal = new THREE.Vector3();
        const _quaternion = new THREE.Quaternion();
        const _color = new THREE.Color();

        // Base colors for variation
        const color1 = new THREE.Color(0x2b4a2b); // Dark green
        const color2 = new THREE.Color(0x44aa00); // Bright green
        const color3 = new THREE.Color(0x88cc00); // Yellowish green

        for (let i = 0; i < GRASS_COUNT; i++) {
            // Random point on sphere
            _normal.set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
            _position.copy(_normal).multiplyScalar(WORLD_RADIUS);

            // Orient to surface normal
            _quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), _normal);

            dummy.position.copy(_position);
            dummy.quaternion.copy(_quaternion);
            dummy.rotateY(Math.random() * Math.PI * 2);
            dummy.scale.setScalar(0.5 + Math.random() * 0.5);
            dummy.updateMatrix();
            grassMesh.setMatrixAt(i, dummy.matrix);

            // Color Variation
            const r = Math.random();
            if (r < 0.33) _color.copy(color1).lerp(color2, Math.random());
            else if (r < 0.66) _color.copy(color2).lerp(color3, Math.random());
            else _color.copy(color3).lerp(color1, Math.random());

            grassMesh.setColorAt(i, _color);
        }
        scene.add(grassMesh);

        // --- 3D Clouds ---
        const cloudCount = 50;
        const cloudGroup = new THREE.Group();
        scene.add(cloudGroup);

        const cloudGeo = new THREE.SphereGeometry(1, 8, 8); // Low poly spheres
        const cloudMat = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.6,
            flatShading: true
        });

        // Create clusters
        for (let i = 0; i < cloudCount; i++) {
            const cluster = new THREE.Group();

            // Random position on sphere shell (higher altitude)
            const altitude = WORLD_RADIUS + 20 + Math.random() * 15;
            const pos = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize().multiplyScalar(altitude);
            cluster.position.copy(pos);
            cluster.lookAt(0, 0, 0); // Orient towards center (or away)

            // Add blobs to cluster
            const blobs = 3 + Math.floor(Math.random() * 5);
            for (let j = 0; j < blobs; j++) {
                const mesh = new THREE.Mesh(cloudGeo, cloudMat);
                mesh.position.set(
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 5,
                    (Math.random() - 0.5) * 10
                );
                mesh.scale.setScalar(2 + Math.random() * 3);
                cluster.add(mesh);
            }

            cloudGroup.add(cluster);
        }


        // --- Procedural Environment (Trees & Buildings) ---
        const treeCount = 50;

        // Geometries
        const trunkGeo = new THREE.CylinderGeometry(0.2, 0.4, 1.5, 6);
        trunkGeo.translate(0, 0.75, 0);

        const foliageGeo = new THREE.ConeGeometry(1.5, 3, 6);
        foliageGeo.translate(0, 1.5 + 1.5, 0);

        // Materials
        const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 });
        const foliageMat = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.8 });

        // Meshes
        const trunkMesh = new THREE.InstancedMesh(trunkGeo, trunkMat, treeCount);
        const foliageMesh = new THREE.InstancedMesh(foliageGeo, foliageMat, treeCount);

        const _dummyObj = new THREE.Object3D();
        const _p = new THREE.Vector3();
        const _n = new THREE.Vector3();
        const _q = new THREE.Quaternion();

        // Generate Trees
        for (let i = 0; i < treeCount; i++) {
            _n.set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
            _p.copy(_n).multiplyScalar(WORLD_RADIUS);
            _q.setFromUnitVectors(new THREE.Vector3(0, 1, 0), _n);

            _dummyObj.position.copy(_p);
            _dummyObj.quaternion.copy(_q);
            _dummyObj.scale.setScalar(0.8 + Math.random() * 0.4);
            _dummyObj.updateMatrix();

            trunkMesh.setMatrixAt(i, _dummyObj.matrix);
            foliageMesh.setMatrixAt(i, _dummyObj.matrix);
        }

        scene.add(trunkMesh);
        scene.add(foliageMesh);

        // Cottage (Single Building)
        let cottageGroup = new THREE.Group();
        _n.set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
        _p.copy(_n).multiplyScalar(WORLD_RADIUS);
        _q.setFromUnitVectors(new THREE.Vector3(0, 1, 0), _n);
        cottageGroup.position.copy(_p);
        cottageGroup.quaternion.copy(_q);

        // Walls
        const walls = new THREE.Mesh(
            new THREE.BoxGeometry(4, 3, 4),
            new THREE.MeshStandardMaterial({ color: 0xC2B280, roughness: 0.9 })
        );
        walls.position.y = 1.5;
        cottageGroup.add(walls);

        // Roof
        const roof = new THREE.Mesh(
            new THREE.ConeGeometry(3.5, 2, 4),
            new THREE.MeshStandardMaterial({ color: 0x8B0000, roughness: 0.6 })
        );
        roof.position.y = 3 + 1;
        roof.rotation.y = Math.PI / 4;
        cottageGroup.add(roof);

        // Door
        const door = new THREE.Mesh(
            new THREE.BoxGeometry(1, 2, 0.2),
            new THREE.MeshStandardMaterial({ color: 0x4A3C31 })
        );
        door.position.set(0, 1, 2.05);
        door.name = "cottage_door"; // Tag for raycasting
        cottageGroup.add(door);

        scene.add(cottageGroup);

        // Helper to spawn a single tree (for destruction event)
        function spawnTreeAt(position, quaternion) {
            const group = new THREE.Group();
            group.position.copy(position);
            group.quaternion.copy(quaternion);

            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            const foliage = new THREE.Mesh(foliageGeo, foliageMat);

            const scale = 0.8 + Math.random() * 0.4;
            group.scale.setScalar(0); // Start scale 0 for animation

            group.add(trunk);
            group.add(foliage);
            scene.add(group);

            // Simple pop-up animation
            let s = 0;
            const animatePop = () => {
                s += 0.05;
                if (s < scale) {
                    group.scale.setScalar(s);
                    requestAnimationFrame(animatePop);
                } else {
                    group.scale.setScalar(scale);
                }
            };
            animatePop();
        }


        // --- Flying Geese ---
        const geeseGroup = new THREE.Group();
        scene.add(geeseGroup);

        // Refined Bird Geometry
        function createBird() {
            const bird = new THREE.Group();

            // Body
            const body = new THREE.Mesh(
                new THREE.ConeGeometry(0.15, 0.6, 8),
                new THREE.MeshStandardMaterial({ color: 0xDDDDDD, roughness: 0.5 })
            );
            body.rotation.x = Math.PI / 2;
            bird.add(body);

            // Head
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.12, 8, 8),
                new THREE.MeshStandardMaterial({ color: 0x333333 })
            );
            head.position.z = 0.3;
            head.position.y = 0.1;
            bird.add(head);

            // Wings (Pivot group for flapping)
            const leftWing = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 0.05, 0.3),
                new THREE.MeshStandardMaterial({ color: 0xBBBBBB })
            );
            leftWing.position.x = -0.4;
            const lwGroup = new THREE.Group();
            lwGroup.add(leftWing);
            lwGroup.name = "leftWing";
            bird.add(lwGroup);

            const rightWing = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 0.05, 0.3),
                new THREE.MeshStandardMaterial({ color: 0xBBBBBB })
            );
            rightWing.position.x = 0.4;
            const rwGroup = new THREE.Group();
            rwGroup.add(rightWing);
            rwGroup.name = "rightWing";
            bird.add(rwGroup);

            return bird;
        }

        // V-Formation
        const flockSize = 7;
        for (let i = 0; i < flockSize; i++) {
            const goose = createBird();

            const row = Math.floor((i + 1) / 2);
            const side = i % 2 === 0 ? 1 : -1;
            if (i === 0) {
                goose.position.set(0, 0, 0);
            } else {
                goose.position.set(side * row * 0.8, 0, row * 0.8);
            }

            geeseGroup.add(goose);
        }

        const flockOrbitRadius = WORLD_RADIUS + 15;
        geeseGroup.position.set(0, flockOrbitRadius, 0);


        // --- Controls & Interaction ---
        const instructions = document.getElementById('instructions');
        const touchInstructions = document.getElementById('touch-instructions');
        const crosshair = document.getElementById('crosshair');
        const handLeft = document.getElementById('hand-left');
        const handRight = document.getElementById('hand-right');

        // Detect touch device (only show mobile controls on small screens)
        const isTouchDevice = (('ontouchstart' in window) || (navigator.maxTouchPoints > 0)) && (window.innerWidth <= 600);

        // Show appropriate instructions and joystick
        if (isTouchDevice) {
            instructions.style.display = 'none';
            touchInstructions.style.display = 'block';
            document.getElementById('joystick-container').style.display = 'block';
            document.getElementById('mobile-pause-btn').style.display = 'flex';

            // Tilt camera down to look more at the grass on mobile
            camera.rotation.x = -0.3; // Tilt down about 17 degrees
        }

        // Mobile pause button handler
        const mobilePauseBtn = document.getElementById('mobile-pause-btn');
        mobilePauseBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            if (isLocked) {
                // Pause game
                isLocked = false;
                touchInstructions.style.opacity = 1;
                mobilePauseBtn.textContent = '‚ñ∂';
            } else {
                // Resume game
                isLocked = true;
                touchInstructions.style.opacity = 0;
                mobilePauseBtn.textContent = '‚è∏';
            }
        });

        // State
        const moveState = { forward: false, backward: false, left: false, right: false };
        let isLocked = false;
        let isLeftClick = false;
        let isRightClick = false;
        const handPosLeft = new THREE.Vector2(-0.3, -0.3);
        const handPosRight = new THREE.Vector2(0.3, -0.3);

        // Touch state
        let joystickActive = false;
        let joystickTouchId = null;
        const joystickCenter = new THREE.Vector2();
        const joystickDirection = new THREE.Vector2();
        const activeTouches = new Map(); // Track grass interaction touches

        // Event Listeners
        document.body.addEventListener('click', () => {
            if (!isLocked) {
                document.body.requestPointerLock();
            }
        });

        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement === document.body) {
                isLocked = true;
                document.body.classList.add('pointer-locked');
                instructions.style.opacity = 0;
                crosshair.style.opacity = 1;
            } else {
                isLocked = false;
                document.body.classList.remove('pointer-locked');
                instructions.style.opacity = 1;
                crosshair.style.opacity = 0;
                isLeftClick = false;
                isRightClick = false;
                handLeft.classList.remove('active');
                handRight.classList.remove('active');
            }
        });

        document.addEventListener('keydown', (e) => {
            switch (e.code) {
                case 'KeyW': moveState.forward = true; break;
                case 'KeyA': moveState.left = true; break;
                case 'KeyS': moveState.backward = true; break;
                case 'KeyD': moveState.right = true; break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch (e.code) {
                case 'KeyW': moveState.forward = false; break;
                case 'KeyA': moveState.left = false; break;
                case 'KeyS': moveState.backward = false; break;
                case 'KeyD': moveState.right = false; break;
            }
        });

        document.addEventListener('mousedown', (e) => {
            if (!isLocked) return;
            if (e.button === 0) {
                isLeftClick = true;
                handLeft.classList.add('active');
                handPosLeft.set(-0.3, -0.3);

                // --- House Destruction Logic ---
                // Raycast from center of screen (crosshair)
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                if (cottageGroup) {
                    const intersects = raycaster.intersectObjects(cottageGroup.children);
                    for (let hit of intersects) {
                        if (hit.object.name === "cottage_door") {
                            // DESTROY!
                            const center = cottageGroup.position.clone();
                            const quat = cottageGroup.quaternion.clone();

                            scene.remove(cottageGroup);
                            cottageGroup = null; // Prevent further interaction

                            // Spawn Trees
                            for (let k = 0; k < 15; k++) {
                                // Random offset in local space
                                const offset = new THREE.Vector3(
                                    (Math.random() - 0.5) * 8,
                                    0,
                                    (Math.random() - 0.5) * 8
                                );
                                // Apply cottage rotation to offset
                                offset.applyQuaternion(quat);

                                const spawnPos = center.clone().add(offset);
                                // Re-project to sphere surface to be safe
                                spawnPos.normalize().multiplyScalar(WORLD_RADIUS);

                                // Calc rotation for this tree
                                const spawnQuat = new THREE.Quaternion().setFromUnitVectors(
                                    new THREE.Vector3(0, 1, 0),
                                    spawnPos.clone().normalize()
                                );

                                spawnTreeAt(spawnPos, spawnQuat);
                            }

                            // Achievement check?
                            addAchievementToUI("Anti Establishment");
                            break;
                        }
                    }
                }

            } else if (e.button === 2) {
                isRightClick = true;
                handRight.classList.add('active');
                handPosRight.set(0.3, -0.3);
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                isLeftClick = false;
                handLeft.classList.remove('active');
            } else if (e.button === 2) {
                isRightClick = false;
                handRight.classList.remove('active');
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (!isLocked) return;

            const sensitivity = 0.002;

            if (isLeftClick || isRightClick) {
                if (isLeftClick) {
                    handPosLeft.x += e.movementX * sensitivity;
                    handPosLeft.y -= e.movementY * sensitivity;
                    handPosLeft.x = Math.max(-1, Math.min(1, handPosLeft.x));
                    handPosLeft.y = Math.max(-1, Math.min(1, handPosLeft.y));
                }
                if (isRightClick) {
                    handPosRight.x += e.movementX * sensitivity;
                    handPosRight.y -= e.movementY * sensitivity;
                    handPosRight.x = Math.max(-1, Math.min(1, handPosRight.x));
                    handPosRight.y = Math.max(-1, Math.min(1, handPosRight.y));
                }
            } else {
                playerGroup.rotateY(-e.movementX * sensitivity);
                camera.rotateX(-e.movementY * sensitivity);
            }
        });

        // --- Touch Controls ---
        const joystickContainer = document.getElementById('joystick-container');
        const joystickBase = document.getElementById('joystick-base');
        const joystickKnob = document.getElementById('joystick-knob');
        const maxJoystickDistance = 35; // Max distance knob can move from center

        // Virtual Joystick Touch Handlers
        joystickBase.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (joystickTouchId === null) {
                const touch = e.changedTouches[0];
                joystickTouchId = touch.identifier;
                joystickActive = true;

                // Calculate joystick center in screen coordinates
                const rect = joystickBase.getBoundingClientRect();
                joystickCenter.set(rect.left + rect.width / 2, rect.top + rect.height / 2);
            }
        }, { passive: false });

        joystickBase.addEventListener('touchmove', (e) => {
            if (!joystickActive) return;

            for (let touch of e.changedTouches) {
                if (touch.identifier === joystickTouchId) {
                    const dx = touch.clientX - joystickCenter.x;
                    const dy = touch.clientY - joystickCenter.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    // Clamp to max distance
                    const clampedDistance = Math.min(distance, maxJoystickDistance);
                    const angle = Math.atan2(dy, dx);

                    // Update knob position
                    const knobX = Math.cos(angle) * clampedDistance;
                    const knobY = Math.sin(angle) * clampedDistance;
                    joystickKnob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`;

                    // Update direction (normalized)
                    if (distance > 5) { // Dead zone
                        joystickDirection.set(dx / distance, dy / distance);

                        // Update movement state based on direction
                        const threshold = 0.5;
                        moveState.forward = joystickDirection.y < -threshold;
                        moveState.backward = joystickDirection.y > threshold;
                        // Left/right now turns instead of strafing
                        moveState.left = false;
                        moveState.right = false;
                    } else {
                        joystickDirection.set(0, 0);
                        moveState.forward = false;
                        moveState.backward = false;
                        moveState.left = false;
                        moveState.right = false;
                    }
                    break;
                }
            }
        }, { passive: true });

        const resetJoystick = () => {
            joystickActive = false;
            joystickTouchId = null;
            joystickKnob.style.transform = 'translate(-50%, -50%)';
            joystickDirection.set(0, 0);
            moveState.forward = false;
            moveState.backward = false;
            moveState.left = false;
            moveState.right = false;
        };

        joystickBase.addEventListener('touchend', (e) => {
            for (let touch of e.changedTouches) {
                if (touch.identifier === joystickTouchId) {
                    resetJoystick();
                    break;
                }
            }
        });

        joystickBase.addEventListener('touchcancel', resetJoystick);

        // Grass Interaction Touch Handlers (Right side of screen)
        document.body.addEventListener('touchstart', (e) => {
            if (!isTouchDevice) return;

            // Auto-lock on first touch if not locked
            if (!isLocked) {
                isLocked = true;
                touchInstructions.style.opacity = 0;
                mobilePauseBtn.textContent = '‚è∏';
                if (isTouchDevice) {
                    crosshair.style.opacity = 0; // Hide crosshair on mobile
                }
            }

            for (let touch of e.changedTouches) {
                // Ignore touches on joystick and pause button
                const target = document.elementFromPoint(touch.clientX, touch.clientY);
                if (target === joystickBase || target === joystickKnob || joystickBase.contains(target) ||
                    target === mobilePauseBtn || mobilePauseBtn.contains(target)) {
                    continue;
                }

                // Check if touch is on right side of screen (for grass interaction)
                if (touch.clientX > window.innerWidth / 2) {
                    activeTouches.set(touch.identifier, {
                        x: touch.clientX,
                        y: touch.clientY,
                        isRight: true
                    });
                }
            }
        }, { passive: true });

        document.body.addEventListener('touchmove', (e) => {
            if (!isTouchDevice || !isLocked) return;

            for (let touch of e.changedTouches) {
                if (activeTouches.has(touch.identifier)) {
                    activeTouches.set(touch.identifier, {
                        x: touch.clientX,
                        y: touch.clientY,
                        isRight: activeTouches.get(touch.identifier).isRight
                    });
                }
            }
        }, { passive: true });

        const removeTouches = (e) => {
            for (let touch of e.changedTouches) {
                activeTouches.delete(touch.identifier);
            }
        };

        document.body.addEventListener('touchend', removeTouches, { passive: true });
        document.body.addEventListener('touchcancel', removeTouches, { passive: true });

        // Prevent context menu on long press
        document.body.addEventListener('contextmenu', (e) => {
            if (isTouchDevice) {
                e.preventDefault();
            }
        });

        // --- Gamification ---
        let totalDistance = 0;
        let lastPos = new THREE.Vector3();
        const scoreValue = document.getElementById('score-value');
        const progressBarFill = document.getElementById('progress-bar-fill');
        const nextAchievementName = document.getElementById('next-achievement-name');
        const achievementsList = document.getElementById('achievements-list');

        const achievements = [
            { id: 'first_touch', name: 'First Touch', threshold: 5, unlocked: false },
            { id: 'sprout', name: 'Sprout', threshold: 25, unlocked: false },
            { id: 'gardener', name: 'Gardener', threshold: 75, unlocked: false },
            { id: 'hiker', name: 'Hiker', threshold: 150, unlocked: false },
            { id: 'artist', name: 'Landscape Artist', threshold: 250, unlocked: false },
            { id: 'circumnavigator', name: 'Circumnavigator', threshold: 314, unlocked: false },
            { id: 'explorer', name: 'Explorer', threshold: 500, unlocked: false },
            { id: 'green_thumb', name: 'Green Thumb', threshold: 750, unlocked: false },
            { id: 'terraformer', name: 'Terraformer', threshold: 1500, unlocked: false },
            { id: 'eco_warrior', name: 'Eco-Warrior', threshold: 3000, unlocked: false },
            { id: 'grass_god', name: 'Grass God', threshold: 10000, unlocked: false }
        ];

        function updateGamification(deltaDist) {
            if (deltaDist <= 0) return;
            // Check if any hand is active (mouse or touch)
            const touchHandActive = activeTouches.size > 0;
            if (isLeftClick || isRightClick || touchHandActive) {
                const multiplier = (isLeftClick && isRightClick) ? 2.0 : 1.0;
                totalDistance += deltaDist * multiplier;
                scoreValue.textContent = Math.floor(totalDistance) + 'm';

                let nextAch = achievements.find(a => !a.unlocked);
                if (nextAch) {
                    nextAchievementName.textContent = nextAch.name;
                    let prevThreshold = 0;
                    const prevAchIndex = achievements.indexOf(nextAch) - 1;
                    if (prevAchIndex >= 0) prevThreshold = achievements[prevAchIndex].threshold;
                    const progress = Math.min(100, ((totalDistance - prevThreshold) / (nextAch.threshold - prevThreshold)) * 100);
                    progressBarFill.style.width = progress + '%';
                    if (totalDistance >= nextAch.threshold) {
                        nextAch.unlocked = true;
                        addAchievementToUI(nextAch.name);
                    }
                } else {
                    nextAchievementName.textContent = "All Unlocked!";
                    progressBarFill.style.width = '100%';
                }
            }
        }

        function addAchievementToUI(name) {
            const div = document.createElement('div');
            div.className = 'achievement-item';
            div.innerHTML = `<span>üèÜ</span> <span>${name}</span>`;
            achievementsList.insertBefore(div, achievementsList.firstChild);
        }

        // --- Animation Loop ---
        const clock = new THREE.Clock();
        const raycaster = new THREE.Raycaster();

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // Rotate Clouds
            cloudGroup.rotation.y += delta * 0.02;
            cloudGroup.rotation.x += delta * 0.005;

            // Animate Geese
            const orbitSpeed = 0.05; // Slower speed
            const timeScale = time * orbitSpeed;
            geeseGroup.position.set(
                Math.sin(timeScale) * (WORLD_RADIUS + 15),
                Math.cos(timeScale * 0.7) * (WORLD_RADIUS + 15) * 0.5,
                Math.cos(timeScale) * (WORLD_RADIUS + 15)
            );

            const nextPos = new THREE.Vector3(
                Math.sin(timeScale + 0.01) * (WORLD_RADIUS + 15),
                Math.cos((timeScale + 0.01) * 0.7) * (WORLD_RADIUS + 15) * 0.5,
                Math.cos(timeScale + 0.01) * (WORLD_RADIUS + 15)
            );
            geeseGroup.lookAt(nextPos);

            // Flap wings
            const flapSpeed = 10;
            const flapAngle = Math.sin(time * flapSpeed) * 0.5;
            geeseGroup.children.forEach(bird => {
                const lw = bird.getObjectByName("leftWing");
                const rw = bird.getObjectByName("rightWing");
                if (lw) lw.rotation.z = flapAngle;
                if (rw) rw.rotation.z = -flapAngle;
            });

            if (isLocked) {
                // --- Movement Logic ---
                const moveSpeed = MOVEMENT_SPEED * delta;

                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(playerGroup.quaternion);
                const right = new THREE.Vector3(1, 0, 0).applyQuaternion(playerGroup.quaternion);

                const normal = playerGroup.position.clone().normalize();

                forward.projectOnPlane(normal).normalize();
                right.projectOnPlane(normal).normalize();

                const moveDir = new THREE.Vector3();
                if (moveState.forward) moveDir.add(forward);
                if (moveState.backward) moveDir.sub(forward);
                if (moveState.right) moveDir.add(right);
                if (moveState.left) moveDir.sub(right);

                if (moveDir.lengthSq() > 0) {
                    moveDir.normalize().multiplyScalar(moveSpeed);

                    // Proposed new position
                    const newPos = playerGroup.position.clone().add(moveDir);
                    newPos.normalize().multiplyScalar(WORLD_RADIUS);

                    // Collision Check (House)
                    let collision = false;
                    if (cottageGroup) {
                        const distToCottage = newPos.distanceTo(cottageGroup.position);
                        if (distToCottage < 4.0) { // Collision Radius
                            collision = true;
                        }
                    }

                    if (!collision) {
                        playerGroup.position.copy(newPos);
                    }
                }

                // --- Joystick Turning Logic ---
                if (isTouchDevice && joystickActive && Math.abs(joystickDirection.x) > 0.3) {
                    const turnSpeed = 2.0 * delta; // Adjust turn speed
                    playerGroup.rotateY(-joystickDirection.x * turnSpeed);
                }

                // --- Orientation Logic (Gravity) ---
                const currentUp = playerGroup.up.clone();
                const targetUp = playerGroup.position.clone().normalize();
                const q = new THREE.Quaternion().setFromUnitVectors(currentUp, targetUp);
                playerGroup.quaternion.premultiply(q);
                playerGroup.up.copy(targetUp);

                // --- Hand Logic ---
                if (isLeftClick) {
                    const x = (handPosLeft.x * 0.5 + 0.5) * window.innerWidth;
                    const y = -(handPosLeft.y * 0.5 - 0.5) * window.innerHeight;
                    handLeft.style.left = x + 'px';
                    handLeft.style.top = y + 'px';

                    raycaster.setFromCamera(handPosLeft, camera);
                    const intersects = raycaster.intersectObject(ground);
                    if (intersects.length > 0) {
                        grassMaterial.uniforms.hand1Pos.value.copy(intersects[0].point);
                        grassMaterial.uniforms.hand1Active.value = 1.0;
                    } else {
                        grassMaterial.uniforms.hand1Active.value = 0.0;
                    }
                } else {
                    grassMaterial.uniforms.hand1Active.value = 0.0;
                }

                if (isRightClick) {
                    const x = (handPosRight.x * 0.5 + 0.5) * window.innerWidth;
                    const y = -(handPosRight.y * 0.5 - 0.5) * window.innerHeight;
                    handRight.style.left = x + 'px';
                    handRight.style.top = y + 'px';

                    raycaster.setFromCamera(handPosRight, camera);
                    const intersects = raycaster.intersectObject(ground);
                    if (intersects.length > 0) {
                        grassMaterial.uniforms.hand2Pos.value.copy(intersects[0].point);
                        grassMaterial.uniforms.hand2Active.value = 1.0;
                    } else {
                        grassMaterial.uniforms.hand2Active.value = 0.0;
                    }
                } else {
                    grassMaterial.uniforms.hand2Active.value = 0.0;
                }

                // --- Hand Logic (Touch) ---
                // Process active touches for grass interaction
                let touchHandActive = false;
                for (let [touchId, touchData] of activeTouches) {
                    if (touchData.isRight) {
                        touchHandActive = true;

                        // Convert screen coordinates to normalized device coordinates
                        const ndcX = (touchData.x / window.innerWidth) * 2 - 1;
                        const ndcY = -(touchData.y / window.innerHeight) * 2 + 1;
                        const touchNDC = new THREE.Vector2(ndcX, ndcY);

                        // Show hand at touch position
                        handRight.style.left = touchData.x + 'px';
                        handRight.style.top = touchData.y + 'px';
                        handRight.classList.add('active');

                        // Raycast to find grass interaction point
                        raycaster.setFromCamera(touchNDC, camera);
                        const intersects = raycaster.intersectObject(ground);
                        if (intersects.length > 0) {
                            grassMaterial.uniforms.hand2Pos.value.copy(intersects[0].point);
                            grassMaterial.uniforms.hand2Active.value = 1.0;
                        }

                        // Only process first touch for now
                        break;
                    }
                }

                if (!touchHandActive && isTouchDevice && !isRightClick) {
                    handRight.classList.remove('active');
                    if (!isRightClick) {
                        grassMaterial.uniforms.hand2Active.value = 0.0;
                    }
                }
            }

            grassMaterial.uniforms.time.value = time;

            const deltaDist = playerGroup.position.distanceTo(lastPos);
            updateGamification(deltaDist);
            lastPos.copy(playerGroup.position);

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>